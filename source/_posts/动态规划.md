---
tags: [算法]
date: 2020-06-08 20:28:45
categories:
- 算法
updated:  2020-06-08 20:28:45
---
## 零钱兑换 II

**给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。**

- 示例 1:

```
输入: amount = 5, coins = [1, 2, 5]
输出: 4
解释: 有四种方式可以凑成总金额:
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
```
- 示例 2:

```
输入: amount = 3, coins = [2]
输出: 0
解释: 只用面额2的硬币不能凑成总金额3。
```

- 示例 3:

```
输入: amount = 10, coins = [10] 
输出: 1
```

### 题解

**模板：**

这是经典的动态编程问题。这是一个可以使用的模板：

- 定义答案显而易见的基本情况。
- 制定根据简单的情况计算复杂情况的策略。
- 将此策略链接到基本情况。

**例子：**

让我们举一个例子：amount = 11，可用硬币面值有 2 美分，5 美分和 10 美分。 请注意，硬币数量是无限的。

![coins](/img/suanfa0.jpeg)

**基本情况：没有硬币或 金币 = 0**

- 如果总金额为 0，那么只有一个组合情况：0。
- 另一个基本情况是没有硬币，若 amount > 0，则组合情况为 0，若 amount == 0，则组合情况为 1。

![基本情况](/img/suanfa1.jpeg)


**2 美分：**

- 让我们用一种硬币做进一步考虑：2 美分

![2 美分](/img/suanfa2.png)

- 很明显，这里可能会有 1 种或 0 种组合。偶数金额为 1 种，奇数金额为 0 种。
- 首先，所有金额均小于 2 美分不会受到 2 美分硬币的影响。 因此对于 amount = 0 和 amount = 1 的结果没有变化。
- amount = 2 开始，可以使用 2 美分硬币进行组合。
- 我们使用 2 美分硬币来组合 amount = 2，则金额 2 美分的组合数等于 amount = 0 的组合数量，即 1。

![1](/img/suanfa3.jpeg)

- 同理 amount = 3 的组合数量等于 amount = 1 的组合数量，即 0。

![0](/img/suanfa4.jpeg)

- 我们可以推到出 `DP` 公式为 `amount = x: dp[x] = dp[x] + dp[x - coin]`，其中 coin = 2 美分，是当前甜腻骄傲硬币的价值。


![2](/img/suanfa5.jpeg)

__2 美分 + 5 美分 + 10 美分：__

- 我们先增加 5 美分的情况，公式是一样的。

![5](/img/suanfa6.jpeg)

- 对于 10 美分也是一样的。

![10](/img/suanfa7.jpeg)

策略为：

- 从基本情况没有硬币开始，一一添加硬币。
- 对于每个添加的硬币，我们从金额 0 到 amount 递归的计算组合数量。

__算法:__

- 以基本情况没有硬币开始组合数量。`dp[0] = 1`，然后其余等于 `0`。
- 遍历所有硬币面值：
  - 对于每个硬币，我们将从金额 0 遍历到 amount：
      - 对于每个 x，计算组合数：`dp[x] += dp[x - coin]`。
- 返回 `dp[amount]`。

### Conclusion

因为我们使用的是一维数组，后面的结果将覆盖前面的结果，所以`dp[x] += dp[x - coin]`并不是巧合或单纯找规律，而是:

> 我们将第 `i - 1` 个硬币记作`A`, 第 `i` 个硬币记为`B`

`dp[x - coin]`**(B's)** 已经在`dp[x]`**(A's)** 之前已经达到了最大组合数，现在只需要将`上个硬币`的最大组合数
`dp[x]`**(A's)**，加上已经组合好的`dp[x - coin]`**(B's)** 就是当前的最大组合数。(Because B own coin add to
`dp[x - coin]`**A or B** ,and it will fit in this case)将`DP`公式解释一下就是: 
`dp[x]`*(B's)* = `dp[x]`*(A's)* + `dp[x - coin]`*(B's)*


```java
class Solution {
  public int change(int amount, int[] coins) {
    int[] dp = new int[amount + 1];
    dp[0] = 1;

    for (int coin : coins) {
      for (int x = coin; x < amount + 1; ++x) {
        dp[x] += dp[x - coin];
      }
    }
    return dp[amount];
  }
}
```

**算法复杂度:**

- 时间复杂度：O(N×amount)。其中 N 为 coins 数组的长度。
- 空间复杂度：O(amount)，dp 数组使用的空间。


> 来源：[力扣（LeetCode）](https://leetcode-cn.com/problems/coin-change-2/solution/ling-qian-dui-huan-ii-by-leetcode/)

## 最大子序和

**给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。**

**示例:**

```
输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```

__进阶:__

如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。


