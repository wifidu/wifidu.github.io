---
tags: [算法]
date: 2020-06-08 20:28:45
categories:
- 算法
updated:  2020-06-08 20:28:45
---
**动态规划与分治法类似，都是把大问题拆分成小问题，通过寻找大问题与小问题的递推关系，解决一个个小问题，最终达到解决原问题的效果。但不同的是，分治法在子问题和子子问题等上被重复计算了很多次，而动态规划则具有记忆性，通过填写表把所有已经解决的子问题答案纪录下来，在新问题里需要用到的子问题可以直接提取，避免了重复计算，从而节约了时间，所以在问题满足最优性原理之后，用动态规划解决问题的核心就在于填表，表填写完毕，最优解也就找到。**

> 采用动态规划，必须要知道初始状态和状态转移方程。

## 零钱兑换 II

**给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。**

- 示例 1:

```
输入: amount = 5, coins = [1, 2, 5]
输出: 4
解释: 有四种方式可以凑成总金额:
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
```
- 示例 2:

```
输入: amount = 3, coins = [2]
输出: 0
解释: 只用面额2的硬币不能凑成总金额3。
```

- 示例 3:

```
输入: amount = 10, coins = [10] 
输出: 1
```

### 题解

**模板：**

这是经典的动态编程问题。这是一个可以使用的模板：

- 定义答案显而易见的基本情况。
- 制定根据简单的情况计算复杂情况的策略。
- 将此策略链接到基本情况。

**例子：**

让我们举一个例子：amount = 11，可用硬币面值有 2 美分，5 美分和 10 美分。 请注意，硬币数量是无限的。

![coins](/img/suanfa0.jpeg)

**基本情况：没有硬币或 金币 = 0**

- 如果总金额为 0，那么只有一个组合情况：0。
- 另一个基本情况是没有硬币，若 amount > 0，则组合情况为 0，若 amount == 0，则组合情况为 1。

![基本情况](/img/suanfa1.jpeg)


**2 美分：**

- 让我们用一种硬币做进一步考虑：2 美分

![2 美分](/img/suanfa2.png)

- 很明显，这里可能会有 1 种或 0 种组合。偶数金额为 1 种，奇数金额为 0 种。
- 首先，所有金额均小于 2 美分不会受到 2 美分硬币的影响。 因此对于 amount = 0 和 amount = 1 的结果没有变化。
- amount = 2 开始，可以使用 2 美分硬币进行组合。
- 我们使用 2 美分硬币来组合 amount = 2，则金额 2 美分的组合数等于 amount = 0 的组合数量，即 1。

![1](/img/suanfa3.jpeg)

- 同理 amount = 3 的组合数量等于 amount = 1 的组合数量，即 0。

![0](/img/suanfa4.jpeg)

- 我们可以推到出 `DP` 公式为 `amount = x: dp[x] = dp[x] + dp[x - coin]`，其中 coin = 2 美分，是当前甜腻骄傲硬币的价值。


![2](/img/suanfa5.jpeg)

__2 美分 + 5 美分 + 10 美分：__

- 我们先增加 5 美分的情况，公式是一样的。

![5](/img/suanfa6.jpeg)

- 对于 10 美分也是一样的。

![10](/img/suanfa7.jpeg)

策略为：

- 从基本情况没有硬币开始，一一添加硬币。
- 对于每个添加的硬币，我们从金额 0 到 amount 递归的计算组合数量。

__算法:__

- 以基本情况没有硬币开始组合数量。`dp[0] = 1`，然后其余等于 `0`。
- 遍历所有硬币面值：
  - 对于每个硬币，我们将从金额 0 遍历到 amount：
      - 对于每个 x，计算组合数：`dp[x] += dp[x - coin]`。
- 返回 `dp[amount]`。

### Conclusion

因为我们使用的是一维数组，后面的结果将覆盖前面的结果，所以`dp[x] += dp[x - coin]`并不是巧合或单纯看图找规律，而是:

> 我们将第 `i - 1` 个硬币记作`A`, 第 `i` 个硬币记为`B`

`dp[x - coin]`**(B's)** 已经在`dp[x]`**(A's)** 之前已经达到了最大组合数，现在只需要将`上个硬币`的最大组合数
`dp[x]`**(A's)**，加上已经组合好的`dp[x - coin]`**(B's)** 就是当前的最大组合数。(Because B own coin add to
`dp[x - coin]`**A or B** ,and it will fit in this case)将`DP`公式解释一下就是: 
`dp[x]`*(B's)* = `dp[x]`*(A's)* + `dp[x - coin]`*(B's)*


```java
class Solution {
  public int change(int amount, int[] coins) {
    int[] dp = new int[amount + 1];
    dp[0] = 1;

    for (int coin : coins) {
      for (int x = coin; x < amount + 1; ++x) {
        dp[x] += dp[x - coin];
      }
    }
    return dp[amount];
  }
}
```

**算法复杂度:**

- 时间复杂度：O(N×amount)。其中 N 为 coins 数组的长度。
- 空间复杂度：O(amount)，dp 数组使用的空间。


> 来源：[力扣（LeetCode）](https://leetcode-cn.com/problems/coin-change-2/solution/ling-qian-dui-huan-ii-by-leetcode/)

## 背包问题

> 背包问题上限为`重量`,硬币上限为`金额`。

> 参考: [1](https://www.cnblogs.com/fengziwei/p/7750849.html) [2](https://blog.csdn.net/chanmufeng/article/details/82955730)

### 0-1背包

采用动态规划，必须要知道初始状态和状态转移方程。

初始状态很容易就能知道，那么状态转移方程如何求呢？对于一件物品，我们有放进或者不放进背包两种选择：

1. 假如我们放进背包，`f[i][j] = f[i - 1][j - weight[i]] + value[i]`，这里的f[i - 1][j - weight[i]] + value[i]应该这么理解：在没放这件物品之前的状态值加上要放进去这件物品的价值。而对于f[i - 1][j - weight[i]]这部分，i - 1很容易理解，关键是 j - weight[i]这里，我们要明白：要把这件物品放进背包，就得在背包里面预留这一部分空间。

2. 假如我们不放进背包，f[i][j] = f[i - 1][j]，这个很容易理解。

因此，我们的状态转移方程就是：`f[i][j] = max(f[i][j] = f[i - 1][j] , f[i - 1][j - weight[i]] + value[i])`

当然，还有一种特殊的情况，就是背包放不下当前这一件物品，这种情况下 `f[i][j] = f[i - 1][j]` 。

```java
public class KnapSack01 {
    public static int knapSack(int[] w, int[] v, int C) {
        int size = w.length;
        if (size == 0) {
            return 0;
        }

        int[][] dp = new int[size][C + 1];
        //初始化第一行
        //仅考虑容量为C的背包放第0个物品的情况
        for (int i = 0; i <= C; i++) {
            dp[0][i] = w[0] <= i ? v[0] : 0;
        }
		//填充其他行和列
        for (int i = 1; i < size; i++) {
            for (int j = 0; j <= C; j++) {
                dp[i][j] = dp[i - 1][j];
                if (w[i] <= j) {
                    dp[i][j] = Math.max(dp[i][j], v[i] + dp[i - 1][j - w[i]]);
                }
            }
        }
        return dp[size - 1][C];
    }

    public static void main(String[] args) {
        int[] w = {2, 1, 3, 2};
        int[] v = {12, 10, 20, 15};
        System.out.println(knapSack(w, v, 5));
    }
}
```

**空间复杂度优化**

我们可以知道，当我们利用一维数组进行记忆化的时候，我们只需要使用到当前位置的值和该位置之前的值，举个例子
假设我们要计算F(i,4)F(i,4)F(i,4),我们需要用到的值为F(i−1,4)F(i-1,4)F(i−1,4)和F(i−1,4−w(i))F(i-1,4-w(i))F(i−1,4−w(i)),因此为了防止结果被覆盖，我们需要从后向前依次计算结果

```java
public class KnapSack01 {
    public static int knapSack(int[] w, int[] v, int C) {
        int size = w.length;
        if (size == 0) {
            return 0;
        }

        int[] dp = new int[C + 1];
        //初始化第一行
        //仅考虑容量为C的背包放第0个物品的情况
        for (int i = 0; i <= C; i++) {
            dp[i] = w[0] <= i ? v[0] : 0;
        }

        for (int i = 1; i < size; i++) {
            for (int j = C; j >= w[i]; j--) {
                dp[j] = Math.max(dp[j], v[i] + dp[j - w[i]]);
            }
        }
        return dp[C];
    }

    public static void main(String[] args) {
        int[] w = {2, 1, 3, 2};
        int[] v = {12, 10, 20, 15};
        System.out.println(knapSack(w, v, 5));
    }
}
```

其中有一段代码优化之前如下:

```java
    for (int i = 1; i <= n; i++) {
        for (int j = m; j >= 1; j--) {
            if (weight[i] <= j) {
                f[j] = f[j] > f[j - weight[i]] + value[i] ? f[j] : f[j - weight[i]] + value[i];
            }
        }
    }
```

### 完全背包

完全背包问题是指每种物品都有无限件

### 多重背包

多重背包问题限定了一种物品的个数，解决多重背包问题，只需要把它转化为0-1背包问题即可。比如，有2件价值为5，重量为2的同一物品，我们就可以分为物品a和物品b，a和b的价值都为5，重量都为2，但我们把它们视作不同的物品。



## 最大子序和

**给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。**

**示例:**

```
输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```

__进阶:__

如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。

### 题解

假设 nums 数组的长度是 n，下标从 0 到 n - 1。

我们用 ai 代表 nums[i]，用 f(i) 代表以第 i 个数结尾的「连续子数组的最大和」，那么很显然我们要求的答案就是：

` max {f(i)} 0≤i≤n−1`

因此我们只需要求出每个位置的 f(i)，然后返回 f 数组中的最大值即可。那么我们如何求 f(i) 呢？我们可以考虑 ai
单独成为一段还是加入 f(i - 1) 对应的那一段，这取决于 ai 和 f(i - 1) + ai
的大小，我们希望获得一个比较大的，于是可以写出这样的动态规划转移方程：

`f(i) = max { f(i - 1) + ai, ai }`

不难给出一个时间复杂度 O(n)、空间复杂度 O(n) 的实现，即用一个 f 数组来保存 f(i) 的值，用一个循环求出所有 f(i)。考虑到 f(i) 只和 
f(i - 1) 相关，于是我们可以只用一个变量 pre 来维护对于当前 f(i) 的 f(i−1) 的值是多少，从而让空间复杂度降低到 O(1)，这有点类似「滚动
数组」的思想。

```javascript
var maxSubArray = function(nums) {
    let pre = 0, maxAns = nums[0];
    nums.forEach((x) => {
        pre = Math.max(pre + x, x);
        maxAns = Math.max(maxAns, pre);
    });
    return maxAns;
};
```
复杂度

时间复杂度：O(n)，其中 n 为 nums 数组的长度。我们只需要遍历一遍数组即可求得答案。
空间复杂度：O(1)。我们只需要常数空间存放若干变量。


来源：[力扣（LeetCode）](https://leetcode-cn.com/problems/maximum-subarray/solution/zui-da-zi-xu-he-by-leetcode-solution/)
