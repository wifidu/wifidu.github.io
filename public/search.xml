<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>动态规划</title>
      <link href="/2020/06/08/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2020/06/08/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h2 id="零钱兑换-II"><a href="#零钱兑换-II" class="headerlink" title="零钱兑换 II"></a>零钱兑换 II</h2><p><strong>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。</strong></p><ul><li>示例 1:</li></ul><pre><code>输入: amount = 5, coins = [1, 2, 5]输出: 4解释: 有四种方式可以凑成总金额:5=55=2+2+15=2+1+1+15=1+1+1+1+1</code></pre><ul><li>示例 2:</li></ul><pre><code>输入: amount = 3, coins = [2]输出: 0解释: 只用面额2的硬币不能凑成总金额3。</code></pre><ul><li>示例 3:</li></ul><pre><code>输入: amount = 10, coins = [10] 输出: 1</code></pre><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>模板：</strong></p><p>这是经典的动态编程问题。这是一个可以使用的模板：</p><ul><li>定义答案显而易见的基本情况。</li><li>制定根据简单的情况计算复杂情况的策略。</li><li>将此策略链接到基本情况。</li></ul><p><strong>例子：</strong></p><p>让我们举一个例子：amount = 11，可用硬币面值有 2 美分，5 美分和 10 美分。 请注意，硬币数量是无限的。</p><p><img src="/img/suanfa0.jpeg" alt="coins"></p><p><strong>基本情况：没有硬币或 金币 = 0</strong></p><ul><li>如果总金额为 0，那么只有一个组合情况：0。</li><li>另一个基本情况是没有硬币，若 amount &gt; 0，则组合情况为 0，若 amount == 0，则组合情况为 1。</li></ul><p><img src="/img/suanfa1.jpeg" alt="基本情况"></p><p><strong>2 美分：</strong></p><ul><li>让我们用一种硬币做进一步考虑：2 美分</li></ul><p><img src="/img/suanfa2.png" alt="2 美分"></p><ul><li>很明显，这里可能会有 1 种或 0 种组合。偶数金额为 1 种，奇数金额为 0 种。</li><li>首先，所有金额均小于 2 美分不会受到 2 美分硬币的影响。 因此对于 amount = 0 和 amount = 1 的结果没有变化。</li><li>amount = 2 开始，可以使用 2 美分硬币进行组合。</li><li>我们使用 2 美分硬币来组合 amount = 2，则金额 2 美分的组合数等于 amount = 0 的组合数量，即 1。</li></ul><p><img src="/img/suanfa3.jpeg" alt="1"></p><ul><li>同理 amount = 3 的组合数量等于 amount = 1 的组合数量，即 0。</li></ul><p><img src="/img/suanfa4.jpeg" alt="0"></p><ul><li>我们可以推到出 <code>DP</code> 公式为 <code>amount = x: dp[x] = dp[x] + dp[x - coin]</code>，其中 coin = 2 美分，是当前甜腻骄傲硬币的价值。</li></ul><p><img src="/img/suanfa5.jpeg" alt="2"></p><p><strong>2 美分 + 5 美分 + 10 美分：</strong></p><ul><li>我们先增加 5 美分的情况，公式是一样的。</li></ul><p><img src="/img/suanfa6.jpeg" alt="5"></p><ul><li>对于 10 美分也是一样的。</li></ul><p><img src="/img/suanfa7.jpeg" alt="10"></p><p>策略为：</p><ul><li>从基本情况没有硬币开始，一一添加硬币。</li><li>对于每个添加的硬币，我们从金额 0 到 amount 递归的计算组合数量。</li></ul><p><strong>算法:</strong></p><ul><li>以基本情况没有硬币开始组合数量。<code>dp[0] = 1</code>，然后其余等于 <code>0</code>。</li><li>遍历所有硬币面值：<ul><li>对于每个硬币，我们将从金额 0 遍历到 amount：<ul><li>对于每个 x，计算组合数：<code>dp[x] += dp[x - coin]</code>。</li></ul></li></ul></li><li>返回 <code>dp[amount]</code>。</li></ul><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>因为我们使用的是一维数组，后面的结果将覆盖前面的结果，所以<code>dp[x] += dp[x - coin]</code>并不是巧合或单纯找规律，而是:</p><blockquote><p>我们将第 <code>i - 1</code> 个硬币记作<code>A</code>, 第 <code>i</code> 个硬币记为<code>B</code></p></blockquote><p><code>dp[x - coin]</code><strong>(B’s)</strong> 已经在<code>dp[x]</code><strong>(A’s)</strong> 之前已经达到了最大组合数，现在只需要将<code>上个硬币</code>的最大组合数<br><code>dp[x]</code><strong>(A’s)</strong>，加上已经组合好的<code>dp[x - coin]</code><strong>(B’s)</strong> 就是当前的最大组合数。(Because B own coin add to<br><code>dp[x - coin]</code><strong>A or B</strong> ,and it will fit in this case)将<code>DP</code>公式解释一下就是:<br><code>dp[x]</code><em>(B’s)</em> = <code>dp[x]</code><em>(A’s)</em> + <code>dp[x - coin]</code><em>(B’s)</em></p><pre><code class="java">class Solution {  public int change(int amount, int[] coins) {    int[] dp = new int[amount + 1];    dp[0] = 1;    for (int coin : coins) {      for (int x = coin; x &lt; amount + 1; ++x) {        dp[x] += dp[x - coin];      }    }    return dp[amount];  }}</code></pre><p><strong>算法复杂度:</strong></p><ul><li>时间复杂度：O(N×amount)。其中 N 为 coins 数组的长度。</li><li>空间复杂度：O(amount)，dp 数组使用的空间。</li></ul><blockquote><p>来源：<a href="https://leetcode-cn.com/problems/coin-change-2/solution/ling-qian-dui-huan-ii-by-leetcode/" target="_blank" rel="noopener">力扣（LeetCode）</a></p></blockquote><h2 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h2><p><strong>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</strong></p><p><strong>示例:</strong></p><pre><code>输入: [-2,1,-3,4,-1,2,1,-5,4],输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</code></pre><p><strong>进阶:</strong></p><p>如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux</title>
      <link href="/2020/06/07/Linux/"/>
      <url>/2020/06/07/Linux/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux知识笔记"><a href="#Linux知识笔记" class="headerlink" title="Linux知识笔记"></a>Linux知识笔记</h1><!-- vim-markdown-toc Redcarpet --><ul><li><a href="#shell">Shell</a><ul><li><a href="#脚本">脚本</a></li><li>[Shell　输入/输出重定向](#shell　输入-输出重定向)</li></ul></li><li><a href="#查询系统负载信息">查询系统负载信息</a></li><li><a href="#useful-commands">Useful commands</a><ul><li><a href="#wc">wc</a></li><li><a href="#ps">ps</a></li><li><a href="#top">top</a></li></ul></li></ul><!-- vim-markdown-toc --><h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><pre><code class="shell">echo -e &quot;OK! \n&quot; # -e 开启转义</code></pre><pre><code class="shell">echo &quot;数组元素个数为: ${#my_array[*]}&quot;echo &quot;数组元素个数为: ${#my_array[@]}&quot;</code></pre><ul><li>拼接字符串</li></ul><pre><code class="shell">your_name=&quot;runoob&quot;# 使用双引号拼接greeting=&quot;hello, &quot;$your_name&quot; !&quot;greeting_1=&quot;hello, ${your_name} !&quot;echo $greeting  $greeting_1# 使用单引号拼接greeting_2=&#39;hello, &#39;$your_name&#39; !&#39;greeting_3=&#39;hello, ${your_name} !&#39;echo $greeting_2  $greeting_3</code></pre><p>输出结果为：</p><pre><code class="shell">hello, runoob ! hello, runoob !hello, runoob ! hello, ${your_name} !</code></pre><ul><li>获取字符串长度</li></ul><pre><code class="shell">string=&quot;abcd&quot;echo ${#string} #输出 4</code></pre><ul><li>提取子字符串</li></ul><pre><code class="shell">以下实例从字符串第 2 个字符开始截取 4 个字符：string=&quot;runoob is a great site&quot;echo ${string:1:4} # 输出 unoo注意：第一个字符的索引值为 0。</code></pre><ul><li>查找子字符串</li></ul><pre><code class="shell">查找字符 i 或 o 的位置(哪个字母先出现就计算哪个)：string=&quot;runoob is a great site&quot;echo `expr index &quot;$string&quot; io`  # 输出 4</code></pre><table><thead><tr><th>参数处理</th><th>说明</th></tr></thead><tbody><tr><td>$#</td><td>传递到脚本的参数个数</td></tr><tr><td><code>$0</code></td><td>当前脚本的文件名</td></tr><tr><td><code>$n</code></td><td>传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2。</td></tr><tr><td>$*</td><td>以一个单字符串显示所有向脚本传递的参数。                                                                                 如”$*”用「”」括起来的情况、以”$1  $2 … $n”的形式输出所有参数。</td></tr><tr><td>$$</td><td>脚本运行的当前进程ID号</td></tr><tr><td>$!</td><td>后台运行的最后一个进程的ID号</td></tr><tr><td>$@</td><td>与$*相同，但是使用时加引号，并在引号中返回每个参数。如”$@”用「”」括起来的情况、以”$1” “$2” … “$n” 的形式输出所有参数。</td></tr><tr><td>$-</td><td>显示Shell使用的当前选项，与set命令功能相同。</td></tr><tr><td>$?</td><td>显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。或返回值。</td></tr></tbody></table><h3 id="Shell-输入-输出重定向"><a href="#Shell-输入-输出重定向" class="headerlink" title="Shell　输入/输出重定向"></a><a href="https://www.runoob.com/linux/linux-shell-io-redirections.html" target="_blank" rel="noopener">Shell　输入/输出重定向</a></h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>command &gt; file</td><td>将输出重定向到 file。</td></tr><tr><td>command &lt; file</td><td>将输入重定向到 file。</td></tr><tr><td>command &gt;&gt; file</td><td>将输出以追加的方式重定向到 file。</td></tr><tr><td>n &gt; file</td><td>将文件描述符为 n 的文件重定向到 file。</td></tr><tr><td>n &gt;&gt; file</td><td>将文件描述符为 n 的文件以追加的方式重定向到 file。</td></tr><tr><td>n &gt;&amp; m</td><td>将输出文件 m 和 n 合并。</td></tr><tr><td>n &lt;&amp; m</td><td>将输入文件 m 和 n 合并。</td></tr><tr><td>&lt;&lt; tag</td><td>将开始标记 tag 和结束标记 tag 之间的内容作为输入。</td></tr></tbody></table><p>一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：</p><ul><li>标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。</li><li>标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。</li><li>标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。</li></ul><p>如果希望将 stdout 和 stderr 合并后重定向到 file，可以这样写：</p><pre><code class="shell">$ command &gt; file 2&gt;&amp;1或者$ command &gt;&gt; file 2&gt;&amp;1</code></pre><p>如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 <code>/dev/null</code>：</p><blockquote><p>/dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到”禁止输出”的效果。</p></blockquote><pre><code class="shell">$ command &gt; /dev/null</code></pre><p>如果希望屏蔽 stdout 和 stderr，可以这样写：</p><pre><code class="shell">$ command &gt; /dev/null 2&gt;&amp;1</code></pre><h2 id="查询系统负载信息"><a href="#查询系统负载信息" class="headerlink" title="查询系统负载信息"></a>查询系统负载信息</h2><blockquote><p>manjaro linux : <code>pacman -S net-tools</code></p></blockquote><p><code>uptime</code> load average后面的三个数分别是1分钟、5分钟、15分钟的负载情况。</p><p><a href="https://www.cnblogs.com/EasonJim/p/8098532.html" target="_blank" rel="noopener">Linux查看某个端口的连接数</a></p><p><a href="https://www.cnblogs.com/ftl1012/p/netstat.html" target="_blank" rel="noopener">netstat</a></p><h2 id="Useful-commands"><a href="#Useful-commands" class="headerlink" title="Useful commands"></a>Useful commands</h2><h3 id="wc"><a href="#wc" class="headerlink" title="wc"></a><a href="https://www.runoob.com/linux/linux-comm-wc.html" target="_blank" rel="noopener">wc</a></h3><blockquote><p>wc命令用于计算字数。</p></blockquote><p><strong>语法</strong></p><pre><code>wc [-clw][--help][--version][文件...]</code></pre><ul><li>-c或–bytes或–chars 只显示Bytes数。</li><li>-l或–lines 只显示行数。</li><li>-w或–words 只显示字数。</li><li>–help 在线帮助。</li><li>–version 显示版本信息。</li></ul><p><strong>e.g.</strong></p><pre><code class="shell">$ wc testfile           # testfile文件的统计信息  3 92 598 testfile       # testfile文件的行数为3、单词数92、字节数598</code></pre><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a><a href="https://www.runoob.com/linux/linux-comm-ps.html" target="_blank" rel="noopener">ps</a></h3><p><strong>语法</strong></p><pre><code>ps [options] [--help]</code></pre><p><strong>e.g.</strong></p><pre><code class="shell"># ps -ef //显示所有命令，连带命令行UID    PID PPID C STIME TTY     TIME CMDroot     1   0 0 10:22 ?    00:00:02 /sbin/initroot     2   0 0 10:22 ?    00:00:00 [kthreadd]root     3   2 0 10:22 ?    00:00:00 [migration/0]root     4   2 0 10:22 ?    00:00:00 [ksoftirqd/0]root     5   2 0 10:22 ?    00:00:00 [watchdog/0]root     6   2 0 10:22 ?    /usr/lib/NetworkManager……省略部分结果root   31302 2095 0 17:42 ?    00:00:00 sshd: root@pts/2 root   31374 31302 0 17:42 pts/2  00:00:00 -bashroot   31400   1 0 17:46 ?    00:00:00 /usr/bin/python /usr/sbin/aptdroot   31407 31374 0 17:48 pts/2  00:00:00 ps -ef</code></pre><h3 id="top"><a href="#top" class="headerlink" title="top"></a><a href="https://www.runoob.com/w3cnote/linux-common-command-2.html" target="_blank" rel="noopener">top</a></h3><p><strong>语法</strong></p><pre><code>-c 显示完整的进程命令-s 保密模式-p &lt;进程号&gt; 指定进程显示-n &lt;次数&gt;循环显示次数</code></pre><p><strong>e.g.</strong></p><pre><code class="shell">top - 14:06:23 up 70 days, 16:44,  2 users,  load average: 1.25, 1.32, 1.35Tasks: 206 total,   1 running, 205 sleeping,   0 stopped,   0 zombieCpu(s):  5.9%us,  3.4%sy,  0.0%ni, 90.4%id,  0.0%wa,  0.0%hi,  0.2%si,  0.0%stMem:  32949016k total, 14411180k used, 18537836k free,   169884k buffersSwap: 32764556k total,        0k used, 32764556k free,  3612636k cachedPID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND  28894 root      22   0 1501m 405m  10m S 52.2  1.3   2534:16 java  </code></pre><p>前五行是当前系统情况整体的统计信息区。</p><ul><li><p>第一行，任务队列信息，同 uptime 命令的执行结果，具体参数说明情况如下：</p><p>14:06:23 — 当前系统时间</p><p>up 70 days, 16:44 — 系统已经运行了70天16小时44分钟（在这期间系统没有重启过的吆！）</p><p>2 users — 当前有2个用户登录系统</p><p>load average: 1.15, 1.42, 1.44 — load average后面的三个数分别是1分钟、5分钟、15分钟的负载情况。</p><p>load average数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了。</p><p><a href="https://blog.csdn.net/ztf312/article/details/80342234" target="_blank" rel="noopener"><strong>load average</strong></a></p></li><li><p>第二行，Tasks — 任务（进程），具体信息说明如下：</p><p>系统现在共有206个进程，其中处于运行中的有1个，205个在休眠（sleep），stoped状态的有0个，zombie状态（僵尸）的有0个。</p></li><li><p>第三行，cpu状态信息，具体属性说明如下：</p></li></ul><pre><code>5.9%us — 用户空间占用CPU的百分比。3.4% sy — 内核空间占用CPU的百分比。0.0% ni — 改变过优先级的进程占用CPU的百分比90.4% id — 空闲CPU百分比0.0% wa — IO等待占用CPU的百分比0.0% hi — 硬中断（Hardware IRQ）占用CPU的百分比0.2% si — 软中断（Software Interrupts）占用CPU的百分比</code></pre><p>备注：在这里CPU的使用比率和windows概念不同，需要理解linux系统用户空间和内核空间的相关知识！</p><p>第四行，内存状态，具体信息如下：</p><pre><code>32949016k total — 物理内存总量（32GB）14411180k used — 使用中的内存总量（14GB）18537836k free — 空闲内存总量（18GB）169884k buffers — 缓存的内存量 （169M）</code></pre><p>第六行，空行。</p><p>第七行以下：各进程（任务）的状态监控，项目列信息说明如下：</p><pre><code>PID — 进程idUSER — 进程所有者PR — 进程优先级NI — nice值。负值表示高优先级，正值表示低优先级VIRT — 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RESRES — 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATASHR — 共享内存大小，单位kbS — 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程%CPU — 上次更新到现在的CPU时间占用百分比%MEM — 进程使用的物理内存百分比TIME+ — 进程使用的CPU时间总计，单位1/100秒COMMAND — 进程名称（命令名/命令行）top 交互命令</code></pre><pre><code>h 显示top交互命令帮助信息c 切换显示命令名称和完整命令行m 以内存使用率排序P 根据CPU使用百分比大小进行排序T 根据时间/累计时间进行排序W 将当前设置写入~/.toprc文件中o或者O 改变显示项目的顺序</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DataStructure</title>
      <link href="/2020/06/07/DataStructure/"/>
      <url>/2020/06/07/DataStructure/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构知识笔记"><a href="#数据结构知识笔记" class="headerlink" title="数据结构知识笔记"></a>数据结构知识笔记</h1><!-- vim-markdown-toc Redcarpet --><ul><li><a href="#二叉树">二叉树</a><ul><li><a href="#遍历">遍历</a></li></ul></li><li><a href="#排序">排序</a></li></ul><!-- vim-markdown-toc --><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><ul><li>已知先序和后序，不能唯一确定二叉树</li><li>已知先序或后序，而又知中序，则能唯一确定二叉树</li><li>先序、中序相同时，二叉树没有左子树</li><li>后序、中序相同时，二叉树没有右子树</li><li>后序、先序相同时，只有一个根节点</li></ul><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a><a href="https://www.cnblogs.com/Glory-D/p/7884525.html" target="_blank" rel="noopener">排序</a></h2><table><thead><tr><th>排序方法</th><th>时间复杂度（平均）</th><th>时间复杂度（最坏)</th><th>时间复杂度（最好)</th><th>空间复杂度</th><th>稳定性</th><th>复杂性</th></tr></thead><tbody><tr><td>直接插入排序</td><td>O(n2)</td><td>O(n2)</td><td>O(n)</td><td>O(1)</td><td>稳定</td><td>简单</td></tr><tr><td>希尔排序</td><td>O(nlog2n)</td><td>O(n2)</td><td>O(n)</td><td>O(1)</td><td>不稳定</td><td>较复杂</td></tr><tr><td>直接选择排序</td><td>O(n2)</td><td>O(n2)</td><td>O(n2)</td><td>O(1)</td><td>不稳定</td><td>简单</td></tr><tr><td>堆排序</td><td>O(nlog2n)</td><td>O(nlog2n)</td><td>O(nlog2n)</td><td>O(1)</td><td>不稳定</td><td>较复杂</td></tr><tr><td>冒泡排序</td><td>O(n2)</td><td>O(n2)</td><td>O(n)</td><td>O(1)</td><td>稳定</td><td>简单</td></tr><tr><td>快速排序</td><td>O(nlog2n)</td><td>O(n2)</td><td>O(nlog2n)</td><td>O(nlog2n)</td><td>不稳定</td><td>较复杂</td></tr><tr><td>归并排序</td><td>O(nlog2n)</td><td>O(nlog2n)</td><td>O(nlog2n)</td><td>O(n)</td><td>稳定</td><td>较复杂</td></tr><tr><td>基数排序</td><td>O(d(n+r))</td><td>O(d(n+r))</td><td>O(d(n+r))</td><td>O(n+r)</td><td>稳定</td><td>较复杂</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> DataStructure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DataStructure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Database</title>
      <link href="/2020/06/07/Database/"/>
      <url>/2020/06/07/Database/</url>
      
        <content type="html"><![CDATA[<h1 id="Database-notes"><a href="#Database-notes" class="headerlink" title="Database notes"></a>Database notes</h1><!-- vim-markdown-toc Redcarpet --><ul><li><a href="#关系型数据库和非关系型数据库">关系型数据库和非关系型数据库</a><ul><li><a href="#关系数据库">关系数据库</a></li><li><a href="#非关系型数据库">非关系型数据库</a></li><li><a href="#对比">对比</a></li></ul></li><li><a href="#redis">redis</a><ul><li><a href="#redis持久化">redis持久化</a><ul><li><a href="#rdb持久化">RDB持久化</a></li><li><a href="#aof持久化">AOF持久化</a></li><li><a href="#优缺点">优缺点</a></li></ul></li></ul></li><li><a href="#mysql">Mysql</a><ul><li><a href="#主键">主键</a></li><li><a href="#引擎">引擎</a></li><li><a href="#索引">索引</a><ul><li><a href="#分类">分类</a></li><li><a href="#索引原理">索引原理</a></li><li><a href="#聚集索引和非聚集索引">聚集索引和非聚集索引</a></li><li><a href="#正确使用索引">正确使用索引</a></li></ul></li></ul></li></ul><!-- vim-markdown-toc --><h2 id="关系型数据库和非关系型数据库"><a href="#关系型数据库和非关系型数据库" class="headerlink" title="关系型数据库和非关系型数据库"></a><a href="https://www.jianshu.com/p/fd7b422d5f93" target="_blank" rel="noopener">关系型数据库和非关系型数据库</a></h2><h3 id="关系数据库"><a href="#关系数据库" class="headerlink" title="关系数据库"></a>关系数据库</h3><blockquote><p>由二维表及其之间的联系组成的一个数据组织。</p></blockquote><ul><li><strong>关系</strong>：一张二维表，每个关系都具有一个关系名，即<strong>表名</strong>。</li><li><strong>元祖</strong>：二维表中的一行，在数据库中被称为<strong>记录</strong>。</li><li><strong>属性</strong>：二维表中的一列，在数据库中被称为<strong>字段</strong>。</li><li><strong>域</strong>　：属性的取值范围，也就是数据库中某一列的取值限制。</li><li>关键字：一组可以唯一标识元组的属性，数据库中常称为主键，由一个或多个列组成</li><li>关系模式：指对关系的描述。其格式为：关系名(属性1，属性2， … … ，属性N)，在数据库中成为表结构</li></ul><p>数据库事务必须具备ACID特性:</p><ol><li>Atomic原子性</li><li>Consistency一致性</li><li>Isolation隔离性</li><li>Durability持久性</li></ol><h3 id="非关系型数据库"><a href="#非关系型数据库" class="headerlink" title="非关系型数据库"></a>非关系型数据库</h3><blockquote><p>没有关系的数据库。指非关系型的，分布式的，且一般不保证遵循ACID原则的数据存储系统。</p></blockquote><blockquote><p>非关系型数据库以键值对存储，且结构不固定，每一个元组可以有不一样的字段，每个元组可以根据需要增加一些自己的键值对，不局限于固定的结构，可以减少一些时间和空间的开销。</p></blockquote><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><ol><li>成本：Nosql数据库简单易部署，基本都是开源软件，不需要像使用Oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。</li><li>查询速度：Nosql数据库将数据存储于缓存之中，而且不需要经过SQL层的解析，关系型数据库将数据存储在硬盘中，自然查询速度远不及Nosql数据库。</li><li>存储数据的格式：Nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。</li><li>扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。Nosql基于键值对，数据之间没有耦合性，所以非常容易水平扩展。</li><li>持久存储：Nosql不使用于持久存储，海量数据的持久存储，还是需要关系型数据库</li><li>数据一致性：非关系型数据库一般强调的是数据最终一致性，不像关系型数据库一样强调数据的强一致性，从非关系型数据库中读到的有可能还是处于一个中间态的数据，<br>Nosql不提供对事务的处理。</li></ol><h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><h3 id="redis持久化"><a href="#redis持久化" class="headerlink" title="redis持久化"></a><a href="https://www.cnblogs.com/wdliu/p/9377278.html" target="_blank" rel="noopener">redis持久化</a></h3><h4 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h4><blockquote><p>RDB持久化方式是通过快照(snapshotting)完成的，当符合一定条件时，redis会自动将内存中所有数据以二进制方式生成一份副本并存储在硬盘上。当redis重启时，并且AOF持久化未开启时，redis会读取RDB持久化生成的二进制文件(默认名称dump.rdb，可通过设置dbfilename修改)进行数据恢复，对于持久化信息可以用过命令“info Persistence”查看。</p></blockquote><p><strong>快照触发条件</strong></p><p>RDB生成快照可自动促发，也可以使用命令手动触发，以下是redis触发执行快照条件，后续会对每个条件详细说明：</p><ol><li>客户端执行命令save和bgsave会生成快照；</li><li>根据配置文件save m n规则进行自动快照；</li><li>主从复制时，从库全量复制同步主库数据，此时主库会执行bgsave命令进行快照；</li><li>客户端执行数据库清空命令FLUSHALL时候，触发快照；</li><li>客户端执行shutdown关闭redis时，触发快照；</li></ol><p><strong>RDB持久化配置</strong></p><pre><code>save m n#配置快照(rdb)促发规则，格式：save &lt;seconds&gt; &lt;changes&gt;#save 900 1  900秒内至少有1个key被改变则做一次快照#save 300 10  300秒内至少有300个key被改变则做一次快照#save 60 10000  60秒内至少有10000个key被改变则做一次快照#关闭该规则使用svae “” dbfilename  dump.rdb#rdb持久化存储数据库文件名，默认为dump.rdbstop-write-on-bgsave-error yes #yes代表当使用bgsave命令持久化出错时候停止写RDB快照文件,no表明忽略错误继续写文件。rdbchecksum yes#在写入文件和读取文件时是否开启rdb文件检查，检查是否有无损坏，如果在启动是检查发现损坏，则停止启动。dir &quot;/etc/redis&quot;#数据文件存放目录，rdb快照文件和aof文件都会存放至该目录，请确保有写权限rdbcompression yes#是否开启RDB文件压缩，该功能可以节约磁盘空间</code></pre><h4 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h4><blockquote><p>当redis存储非临时数据时，为了降低redis故障而引起的数据丢失，redis提供了AOF(Append Only File)持久化，从单词意思讲，将命令追加到文件。AOF可以将Redis执行的每一条写命令追加到磁盘文件(appendonly.aof)中,在redis启动时候优先选择从AOF文件恢复数据。由于每一次的写操作，redis都会记录到文件中，所以开启AOF持久化会对性能有一定的影响，但是大部分情况下这个影响是可以接受的，我们可以使用读写速率高的硬盘提高AOF性能。与RDB持久化相比，AOF持久化数据丢失更少，其消耗内存更少(RDB方式执行bgsve会有内存拷贝)。</p></blockquote><p><strong>开启AOF</strong></p><blockquote><p>默认情况下，redis是关闭了AOF持久化，开启AOF通过配置appendonly为yes开启，我们修改配置文件或者在命令行直接使用config set修改，在用config rewrite同步到配置文件。通过客户端修改好处是不用重启redis，AOF持久化直接生效。</p></blockquote><p><strong>重写触发条件</strong></p><p>AOF文件触发条件可分为手动触发和自动触发：</p><ul><li>手动触发：客户端执行bgrewriteaof命令。</li><li>自动触发：自动触发通过以下两个配置协作生效：<ul><li>auto-aof-rewrite-min-size: AOF文件最小重写大小，只有当AOF文件大小大于该值时候才可能重写,4.0默认配置64mb。</li><li>auto-aof-rewrite-percentage：当前AOF文件大小和最后一次重写后的大小之间的比率等于或者等于指定的增长百分比，如100代表当前AOF文件是上次重写的两倍时候才重写。　</li></ul></li></ul><blockquote><p>redis开启AOF之后会维护以上条件所需变量</p></blockquote><p><strong>AOF实现本质</strong></p><p>AOF实现本质是基于redis通讯协议，将命令以纯文本的方式写入到文件中。<br>redis协议：</p><p>首先Redis是以行来划分，每行以\r\n行结束。每一行都有一个消息头，消息头共分为5种分别如下:</p><p>(+) 表示一个正确的状态信息，具体信息是当前行+后面的字符。</p><p>(-)  表示一个错误信息，具体信息是当前行－后面的字符。</p><p>(<em>) 表示消息体总共有多少行，不包括当前行,</em>后面是具体的行数。</p><p>($) 表示下一行数据长度，不包括换行符长度\r\n,$后面则是对应的长度的数据。</p><p>(：) 表示返回一个数值，：后面是相应的数字节符。</p><p><strong>AOF配置参数</strong></p><pre><code>auto-aof-rewrite-min-size 64mb#AOF文件最小重写大小，只有当AOF文件大小大于该值时候才可能重写,4.0默认配置64mb。auto-aof-rewrite-percentage  100#当前AOF文件大小和最后一次重写后的大小之间的比率等于或者等于指定的增长百分比，如100代表当前AOF文件是上次重写的两倍时候才重写。appendfsync everysec#no：不使用fsync方法同步，而是交给操作系统write函数去执行同步操作，在linux操作系统中大约每30秒刷一次缓冲。这种情况下，缓冲区数据同步不可控，并且在大量的写操作下，aof_buf缓冲区会堆积会越来越严重，一旦redis出现故障，数据#always：表示每次有写操作都调用fsync方法强制内核将数据写入到aof文件。这种情况下由于每次写命令都写到了文件中, 虽然数据比较安全，但是因为每次写操作都会同步到AOF文件中，所以在性能上会有影响，同时由于频繁的IO操作，硬盘的使用寿命会降低。#everysec：数据将使用调用操作系统write写入文件，并使用fsync每秒一次从内核刷新到磁盘。 这是折中的方案，兼顾性能和数据安全，所以redis默认推荐使用该配置。aof-load-truncated yes#当redis突然运行崩溃时，会出现aof文件被截断的情况，Redis可以在发生这种情况时退出并加载错误，以下选项控制此行为。#如果aof-load-truncated设置为yes，则加载截断的AOF文件，Redis服务器启动发出日志以通知用户该事件。#如果该选项设置为no，则服务将中止并显示错误并停止启动。当该选项设置为no时，用户需要在重启之前使用“redis-check-aof”实用程序修复AOF文件在进行启动。appendonly no #yes开启AOF，no关闭AOFappendfilename appendonly.aof#指定AOF文件名，4.0无法通过config set 设置，只能通过修改配置文件设置。dir /etc/redis#RDB文件和AOF文件存放目录</code></pre><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>RDB</strong></p><p><strong>优点</strong>：</p><ul><li>RDB 是一个非常紧凑（compact）的文件，体积小，因此在传输速度上比较快，因此适合灾难恢复。</li><li>RDB 可以最大化 Redis 的性能：父进程在保存 RDB 文件时唯一要做的就是 fork 出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘 I/O 操作。</li><li>RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</li></ul><p><strong>缺点</strong>：</p><ul><li>RDB是一个快照过程，无法完整的保存所以数据，尤其在数据量比较大时候，一旦出现故障丢失的数据将更多。</li><li>当redis中数据集比较大时候，RDB由于RDB方式需要对数据进行完成拷贝并生成快照文件，fork的子进程会耗CPU，并且数据越大，RDB快照生成会越耗时。</li><li>RDB文件是特定的格式，阅读性差，由于格式固定，可能存在不兼容情况。</li></ul><p><strong>AOF</strong></p><p><strong>优点</strong>：</p><ul><li>数据更完整，秒级数据丢失(取决于设置fsync策略)。</li><li>兼容性较高，由于是基于redis通讯协议而形成的命令追加方式，无论何种版本的redis都兼容，再者aof文件是明文的，可阅读性较好。</li></ul><p><strong>缺点</strong>：</p><ul><li>数据文件体积较大,即使有重写机制，但是在相同的数据集情况下，AOF文件通常比RDB文件大。</li><li>相对RDB方式，AOF速度慢于RDB，并且在数据量大时候，恢复速度AOF速度也是慢于RDB。</li><li>由于频繁地将命令同步到文件中，AOF持久化对性能的影响相对RDB较大，但是对于我们来说是可以接受的。</li></ul><h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h2><p><code>mysql_secure_installation</code></p><pre><code class="shell">pacman -S php-fpm libapache2-mod-php php-mysql</code></pre><h3 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h3><p>表通常具有包含唯一标识表中每一行的值的一列或一组列。这样的一列或多列称为表的主键 (PK)，用于强制表的实体完整性。在创建或修改表时，您可以通过定义 PRIMARY KEY 约束来创建主键。</p><blockquote><p>创建主键时，数据库引擎 会自动创建唯一的索引来强制实施 PRIMARY KEY 约束的唯一性要求。如果表中不存在聚集索引或未显式指定非聚集索引，则将创建唯一的聚集索引以强制实施 PRIMARY KEY 约束。</p></blockquote><h3 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h3><p>InnoDB 支持事务，支持行级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引；<br>MyISAM 不支持事务，支持表级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引；<br>Memory 不支持事务，支持表级别锁定，支持 B-tree、Hash 等索引，不支持 Full-text 索引；<br>NDB 支持事务，支持行级别锁定，支持 Hash 索引，不支持 B-tree、Full-text 等索引；<br>Archive 不支持事务，支持表级别锁定，不支持 B-tree、Hash、Full-text 等索引；</p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>我们可以在创建上述索引的时候，为其指定索引类型，分两类:</p><ul><li>hash类型的索引：查询单条快，范围查询慢</li><li>btree类型的索引：b+树，层数越多，数据量指数级增长（我们就用它，因为innodb默认支持它）</li></ul><blockquote><p>表中除了聚集索引外其他索引都是辅助索引（Secondary Index，也称为非聚集索引）（unique key啊、index key啊），与聚集索引的区别是：辅助索引的叶子节点不包含行记录的全部数据。</p></blockquote><p>常用索引：</p><ul><li><p>普通索引INDEX：加速查找</p></li><li><p>唯一索引：</p><ul><li>主键索引PRIMARY KEY：加速查找+约束（不为空、不能重复）</li><li>唯一索引UNIQUE:加速查找+约束（不能重复）</li></ul></li><li><p>联合索引：</p><ul><li>PRIMARY KEY(id,name):联合主键索引</li><li>UNIQUE(id,name):联合唯一索引</li><li>INDEX(id,name):联合普通索引</li></ul></li></ul><h4 id="索引原理"><a href="#索引原理" class="headerlink" title="索引原理"></a>索引原理</h4><p><a href="https://www.cnblogs.com/fengqiang626/archive/2019/09/04/11459434.html#1%E4%BB%8B%E7%BB%8D" target="_blank" rel="noopener">Link</a></p><h4 id="聚集索引和非聚集索引"><a href="#聚集索引和非聚集索引" class="headerlink" title="聚集索引和非聚集索引"></a>聚集索引和非聚集索引</h4><blockquote><p>主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚集索引（clustered index）。</p></blockquote><blockquote><p>非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。</p></blockquote><ol><li><p>mysql的innodb表，就是索引组织表，表中的所有数据行都放在索引上，这就约定了数据是严格按照顺序存放的，所以不管插入的先后顺序，它在那个物理上的那个位置与插入的先后顺序无关。</p></li><li><p>聚集索引，叶子节点存的是整行数据，直接通过这个聚集索引的键值找到某行</p></li><li><p>聚集索引，数据的物理存放顺序与索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的。</p></li><li><p>聚集索引，数据行和相邻的键值紧凑地存储在一起，因为无法同时把数据行存放在两个不同的地方，所以一个表只能有一个聚集索引。</p></li><li><p>非聚集索引，叶子节点存的是字段的值，通过这个非聚集索引的键值找到对应的聚集索引字段的值，再通过聚集索引键值找到表的某行，类似oracle通过键值找到rowid，再通过rowid找到行</p></li><li><p>mysql的innodb表，其聚集索引相当于整张表，而整张表也是聚集索引。默认通过主键聚集数据，如果没有定义主键，则选择第一个非空的唯一索引，如果没有非空唯一索引，则选择rowid来作为聚集索引</p></li><li><p>mysql的innodb表，因为整张表也是聚集索引，select出来的结果是顺序排序的，比如主键字段的数据插入顺序可以是5、3、4、2、1,查询时不带order by得出的结果也是按1、2、3、4、5排序</p></li><li><p>通俗理解</p><ul><li><p>聚集索引：类似新华字典正文内容本身就是一种按照一定规则排列的目录</p></li><li><p>非聚集索引：这种目录纯粹是目录，正文纯粹是正文的排序方式</p></li><li><p>每个表只能有一个聚集索引，因为目录只能按照一种方法进行排序 。</p></li></ul></li><li><p>oracle一般使用堆表，mysql的innodb是索引组织表</p><ul><li><p>堆表以一种显然随机的方式管理，数据插入时时存储位置是随机的，主要是数据库内部块的空闲情况决定，数据会放在最合适的地方，而不是以某种特定顺序来放置。</p></li><li><p>堆表的存储速度因为不用考虑排序, 所以存储速度会比较快. 但是要查找符合某个条件的记录, 就必须得读取全部的记录以便筛选。</p></li><li><p>堆表其索引中记录了记录所在位置的rowid，查找的时候先找索引，然后再根据索引rowid找到块中的行数据。</p></li><li><p>堆表的索引和表数据是分离的</p></li><li><p>索引组织表，其行数据以索引形式存放，因此找到索引，就等于找到了行数据。</p></li><li><p>索引组织表索引和数据是在一起的</p></li></ul></li></ol><p>如果语句是 select * from T where ID=500，即 主键查询方式，则只需要搜索 ID 这棵 B+树 ；</p><p>如果语句是 select * from T where k=5，即 普通索引查询方式，则需要先搜索 k 索引树，得到 ID的值为 500，再到 ID 索引树搜索一次。这个过程称为回表</p><p>B+ 树为了维护索引有序性，在插入新值的时候需要做必要的维护。以上面为例，如果插入新的行 ID 值为 700，则只只需要在 R5 的记录后面插入一个新记录。如果新插入的 ID值为 400，就相对麻烦了，需要逻辑上挪动后面的数据，空出位置。</p><p>test1表 innodb引擎，索引和数据放在一个文件里面</p><p>-rw-r—– 1 mysql mysql  8678 Nov 20 14:05 test1.frm</p><p>-rw-r—– 1 mysql mysql 98304 Nov 20 16:51 test1.ibd</p><p>test2表 myisam引擎，索引和数据放在不同文件</p><p>-rw-r—– 1 mysql mysql  8558 Nov 22 10:22 test2.frm</p><p>-rw-r—– 1 mysql mysql     0 Nov 22 10:22 test2.MYD</p><p>-rw-r—– 1 mysql mysql  1024 Nov 22 10:22 test2.MYI</p><p><strong>InnoDB表的行被组织成称为聚集索引的索引结构 ，条目根据表的主键列进行排序。 数据访问针对对主键列进行筛选和排序的查询进行了优化，每个索引都包含每个条目的关联主键列的副本。 修改任何主键列的值是一项昂贵的操作。 因此，InnoDB表设计的一个重要方面是选择一个主键，该主键具有在最重要的查询中使用的列，并保持主键很短，很少更改值。</strong></p><blockquote><p>InnoDB术语表示主键索引。 InnoDB表存储基于主键列的值进行组织，以加速涉及主键列的查询和排序。 为获得最佳性能，请根据性能最关键的查询仔细选择主键列。 因为修改聚集索引的列是一项昂贵的操作，所以选择很少或从不更新的主列。在Oracle数据库产品中，此类表称为索引组织表。</p></blockquote><p>每个InnoDB表都有一个称为聚集索引的特殊索引，其中存储了行的数据。通常，聚集索引与主键同义。</p><p>在表上定义PRIMARY KEY时，InnoDB将其用作聚集索引 。为您创建的每个表定义主键。如果没有逻辑唯一且非空列或一组列，请添加一个新的自动增量列，其值将自动填充。</p><p>如果没有为表定义PRIMARY KEY，MySQL将找到第一个UNIQUE索引，其中所有键列都是NOT NULL，而InnoDB将它用作聚集索引。</p><p>如果表没有PRIMARY KEY或合适的UNIQUE索引，InnoDB会在包含行ID值的合成列内部生成名为GEN_CLUST_INDEX的隐藏聚集索引 。这些行按InnoDB分配给此类表中的行的ID排序。行ID是一个6字节的字段，在插入新行时会单调增加。因此，由行ID排序的行在物理上处于插入顺序。</p><p>通过聚集索引访问行很快，因为索引搜索直接指向包含所有行数据的页面。 如果表很大，则与使用与索引记录不同的页面存储行数据的存储组织相比，聚集索引体系结构通常会保存磁盘I / O操作。</p><p>除聚集索引之外的所有索引都称为辅助索引。 在InnoDB中，辅助索引中的每个记录都包含该行的主键列以及为辅助索引指定的列。 InnoDB使用此主键值来搜索聚集索引中的行。</p><h4 id="正确使用索引"><a href="#正确使用索引" class="headerlink" title="正确使用索引"></a><a href="https://www.cnblogs.com/fengqiang626/archive/2019/09/04/11459434.html#7%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95" target="_blank" rel="noopener">正确使用索引</a></h4>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Computer</title>
      <link href="/2020/06/07/Computer/"/>
      <url>/2020/06/07/Computer/</url>
      
        <content type="html"><![CDATA[<h1 id="面试题问题笔记"><a href="#面试题问题笔记" class="headerlink" title="面试题问题笔记"></a>面试题问题笔记</h1><!-- vim-markdown-toc Redcarpet --><ul><li><a href="#堆栈的区别">堆栈的区别</a></li><li><a href="#进程和线程">进程和线程</a><ul><li><a href="#什么是进程">什么是进程</a></li><li><a href="#什么是线程">什么是线程</a></li><li><a href="#区别">区别</a></li></ul></li><li><a href="#互联网协议">互联网协议</a><ul><li><a href="#实体层">实体层</a></li><li><a href="#链接层">链接层</a><ul><li><a href="#以太网协议">以太网协议</a></li><li><a href="#mac地址">MAC地址</a></li><li><a href="#广播">广播</a></li></ul></li><li><a href="#网络层">网络层</a><ul><li><a href="#ip地址">IP地址</a></li><li><a href="#ip数据包">IP数据包</a></li><li><a href="#arp协议">ARP协议</a></li></ul></li><li><a href="#传输层">传输层</a><ul><li><a href="#udp协议">UDP协议</a></li><li><a href="#tcp协议">TCP协议</a></li></ul></li><li><a href="#应用层">应用层</a></li></ul></li></ul><!-- vim-markdown-toc --><h2 id="堆栈的区别"><a href="#堆栈的区别" class="headerlink" title="堆栈的区别"></a><a href="https://www.php.cn/faq/416802.html" target="_blank" rel="noopener">堆栈的区别</a></h2><ol><li><p>栈内存存储的是局部变量而堆内存存储的是实体；</p></li><li><p>栈内存的更新速度要快于堆内存，因为局部变量的生命周期很短；</p></li><li><p>栈内存存放的变量生命周期一旦结束就会被释放，而堆内存存放的实体会被垃圾回收机制不定时的回收。</p></li></ol><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a><a href="https://www.cnblogs.com/aaronthon/p/9824396.html" target="_blank" rel="noopener">进程和线程</a></h2><h4 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h4><ul><li>进程是资源(CPU、内存等)分配的基本单位，它是程序执行时的一个实例。</li><li>程序运行时系统就会创建一个进程，并为它分配资源，然后把该进程放入进程就绪队列。</li><li>进程调度器选中它的时候就会为它分配CPU时间，程序开始真正运行。</li></ul><h4 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h4><ul><li>线程是程序执行时的最小单位，它是进程的一个执行流，是CPU调度和分配的基本单位。</li><li>一个进程可以由很多个线程组成，线程间共享进程的所有资源，每个线程有自己的堆栈和局部变量。</li><li>线程由CPU独立调度执行，在多CPU环境下就允许多个线程同时运行。同样多线程也可以实现并发操作，每个请求分配一个线程来处理。</li></ul><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li>地址空间和其他资源：进程间相互独立，同一进程的各线程间共享。某进程内的县城在其他进程内不可见。</li><li>通信：进程间通信IPC(管道，信号量，共享内存，消息队列)，线程间可以直接单独写进程数据段(如全局变量)来进程通信。</li><li>线程上下文切换比进程上下文切换快的多。</li><li>在多线程OS中，进程不是一个可执行的实体。</li><li><a href="https://blog.csdn.net/wsq119/article/details/82154305" target="_blank" rel="noopener">more</a></li></ul><h2 id="互联网协议"><a href="#互联网协议" class="headerlink" title="互联网协议"></a>互联网协议</h2><blockquote><p>互联网模型有五层：<code>应用层</code>、<code>传输层</code>、<code>网络层</code>、<code>链接层</code>、<code>实体层</code></p></blockquote><h3 id="实体层"><a href="#实体层" class="headerlink" title="实体层"></a>实体层</h3><p>就是把电脑连接起来的物理手段。它主要规定了网络的一些电气特性，作用是负责传送0和1的电信号。</p><h3 id="链接层"><a href="#链接层" class="headerlink" title="链接层"></a>链接层</h3><p>单纯的0和1没有任何意义，必须规定解读方式：多少个电信号算一组？每个信号位有何意义？(所以<strong>以太网</strong>协议出现了)</p><p>这就是”链接层”的功能，它在”实体层”的上方，确定了0和1的分组方式。</p><h4 id="以太网协议"><a href="#以太网协议" class="headerlink" title="以太网协议"></a>以太网协议</h4><p>以太网规定，一组电信号构成一个数据包，叫做”帧”（Frame）。每一帧分成两个部分：标头（Head）和数据（Data）。</p><h4 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h4><p>以太网规定，连入网络的所有设备，都必须具有”网卡”接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址。</p><p>每块网卡出厂的时候，都有一个全世界独一无二的MAC地址，长度是48个二进制位，通常用12个十六进制数表示。</p><h4 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h4><p>首先，一块网卡怎么会知道另一块网卡的MAC地址？</p><p>回答是有一种<code>ARP协议</code>，可以解决这个问题。这个留到后面介绍，这里只需要知道，以太网数据包必须知道接收方的MAC地址，然后才能发送。</p><p>其次，就算有了MAC地址，系统怎样才能把数据包准确送到接收方？</p><p>回答是以太网采用了一种很”原始”的方式，它不是把数据包准确送到接收方，而是向本网络内所有计算机发送，让每台计算机自己判断，是否为接收方。</p><hr><p>有了数据包的定义、网卡的MAC地址、广播的发送方式，”链接层”就可以在多台计算机之间传送数据了。</p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>互联网是无数子网络共同组成的一个巨型网络，很像想象上海和洛杉矶的电脑会在同一个子网络，这几乎是不可能的。</p><p>这就导致了”网络层”的诞生。它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做”<strong>网络地址</strong>“，简称”网址”。</p><h4 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h4><p>规定<strong>网络地址</strong>的协议，叫做IP协议。它所定义的地址，就被称为IP地址。</p><p>目前，广泛采用的是IP协议第四版，简称IPv4。这个版本规定，网络地址由32个二进制位组成。</p><p>互联网上的每一台计算机，都会分配到一个IP地址。这个地址分成两个部分，前一部分代表网络，后一部分代表主机。比如，IP地址172.16.254.1，这是一个32位的地址，假定它的网络部分是前24位（172.16.254），那么主机部分就是后8位（最后的那个1）。处于同一个子网络的电脑，它们IP地址的网络部分必定是相同的，也就是说172.16.254.2应该与172.16.254.1处在同一个子网络。</p><p>知道”子网掩码”，我们就能判断，任意两个IP地址是否处在同一个子网络。方法是将两个IP地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。</p><blockquote><p>IP协议的作用主要有两个，一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络。</p></blockquote><h4 id="IP数据包"><a href="#IP数据包" class="headerlink" title="IP数据包"></a>IP数据包</h4><p>根据IP协议发送的数据，就叫做IP数据包。不难想象，其中必定包括IP地址信息。</p><p>我们可以把IP数据包直接放进以太网数据包的”数据”部分，因此完全不用修改以太网的规格。这就是互联网分层结构的好处：上层的变动完全不涉及下层的结构。</p><p>具体来说，IP数据包也分为”标头”和”数据”两个部分。</p><h4 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h4><p>如果两台主机在同一个子网络，那么我们可以用ARP协议，得到对方的MAC地址。ARP协议也是发出一个数据包（包含在以太网数据包中），其中包含它所要查询主机的IP地址，在对方的MAC地址这一栏，填的是FF:FF:FF:FF:FF:FF，表示这是一个”广播”地址。它所在子网络的每一台主机，都会收到这个数据包，从中取出IP地址，与自身的IP地址进行比较。如果两者相同，都做出回复，向对方报告自己的MAC地址，否则就丢弃这个包。</p><p>总之，有了ARP协议之后，我们就可以得到同一个子网络内的主机MAC地址，可以把数据包发送到任意一台主机之上了。</p><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>有了MAC地址和IP地址，我们已经可以在互联网上任意两台主机上建立通信。</p><p>接下来的问题是，同一台主机上有许多程序都需要用到网络，比如，你一边浏览网页，一边与朋友在线聊天。当一个数据包从互联网上发来的时候，你怎么知道，它是表示网页的内容，还是表示在线聊天的内容？</p><p>“端口”是0到65535之间的一个整数，正好16个二进制位。0到1023的端口被系统占用，用户只能选用大于1023的端口。不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口联系。</p><p><strong>“传输层”的功能，就是建立”端口到端口”的通信。相比之下，”网络层”的功能是建立”主机到主机”的通信。只要确定主机和端口，我们就能实现程序之间的交流。因此，Unix系统就把主机+端口，叫做”套接字”（socket）。有了它，就可以进行网络应用程序开发了。</strong></p><h4 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h4><p>现在，我们必须在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做UDP协议，它的格式几乎就是在数据前面，加上端口号。</p><p>UDP数据包，也是由”标头”和”数据”两部分组成。</p><p>“标头”部分主要定义了发出端口和接收端口，”数据”部分就是具体的内容。然后，把整个UDP数据包放入IP数据包的”数据”部分，而前面说过，IP数据包又是放在以太网数据包之中的</p><h4 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h4><p>UDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。</p><p>为了解决这个问题，提高网络可靠性，TCP协议就诞生了。这个协议非常复杂，但可以近似认为，它就是有确认机制的UDP协议，每发出一个数据包都要求确认。如果有一个数据包遗失，就收不到确认，发出方就知道有必要重发这个数据包了。</p><p>因此，TCP协议能够确保数据不会遗失。它的缺点是过程复杂、实现困难、消耗较多的资源。</p><p>TCP数据包和UDP数据包一样，都是内嵌在IP数据包的”数据”部分。TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。</p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>应用程序收到”传输层”的数据，接下来就要进行解读。由于互联网是开放架构，数据来源五花八门，必须事先规定好格式，否则根本无法解读。</p><blockquote><p>“应用层”的作用，就是规定应用程序的数据格式。</p></blockquote><p>举例来说，TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了”应用层”。</p>]]></content>
      
      
      <categories>
          
          <category> Computer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP</title>
      <link href="/2020/06/05/PHP/"/>
      <url>/2020/06/05/PHP/</url>
      
        <content type="html"><![CDATA[<h1 id="PHP-Notes"><a href="#PHP-Notes" class="headerlink" title="PHP Notes"></a>PHP Notes</h1><!-- vim-markdown-toc Redcarpet --><ul><li><a href="#正则表达式">正则表达式</a></li></ul><!-- vim-markdown-toc --><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><table><thead><tr><th>/i</th><th>(忽略大小写)</th></tr></thead><tbody><tr><td>/g</td><td>(全文查找出现的所有匹配字符)</td></tr><tr><td>/m</td><td>(多行查找)</td></tr><tr><td>/gi</td><td>(全文查找、忽略大小写)</td></tr><tr><td>/ig</td><td>(全文查找、忽略大小写)</td></tr></tbody></table><pre><code>mixed preg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit = -1 [, int &amp;$count ]] )搜索 subject 中匹配 pattern 的部分， 以 replacement 进行替换。</code></pre><p>参数说明：</p><ul><li><p>$pattern: 要搜索的模式，可以是字符串或一个字符串数组。</p></li><li><p>$replacement: 用于替换的字符串或字符串数组。</p></li><li><p>$subject: 要搜索替换的目标字符串或字符串数组。</p></li><li><p>$limit: 可选，对于每个模式用于每个 subject 字符串的最大可替换次数。 默认是-1（无限制）。</p></li><li><p>$count: 可选，为替换执行的次数。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
